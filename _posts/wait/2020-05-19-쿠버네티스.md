---
layout: post
title: 쿠버네티스
tags: [쿠버네티스, Kubernetes]
---
# 쿠버네티스

## 오브젝트

* 영속성을 가지는 개체이다
* 클러스터의 상태를 나타내기 위해 이 개체를 이용한다.
  * 어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)
  * 그 애플리케이션이 이용할 수 있는 리소스
  * 그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성과 같은 것에 동작해야 하는지에 대한 정책
* 하나의 "의도를 담은 레코드"이다.
* 오브젝트를 생성하면, 쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 작동한다.

### 명세와 상태

#### 명세

* 오브젝트를 생성할 때 리소스에 원하는 특징(의동한 상태)에 대한 설명을 제공한다.
* 커맨드라인에서 오브젝트 생성시 인자로 전달하여 정의하거나 yaml이나 json 파일로 정의할 수 있다.

#### 상태

* 오브젝트의 현재 상태를 설명한다.
* 쿠버네티스의 컨트롤 플레인[^1]은 모든 오브젝트의 실제 상태를 사용자가 의도한 상태(명세)와 일치시키기 위해 끊임없이 그리고 능동적으로 관리한다.

### 기본 오브젝트

가장 기본적인 구성단위이며 다음과 같은 것들이 있다.

* Pod : 컨테이너화된 어플리케이션
* Volume : 디스크
* Service : 로드밸런서
* Namespace : 패키지 이름

### 컨트롤러

* 기본 오브젝트를 생성하고 관리한다.

## Deployment

- Stateless 앱을 배포할 때 사용하는 가장 기본적인 컨트롤러이다.
- 쿠버네티스가 애플리케이션의 인스턴스를 어떻게 생성하고 업데이트 해야 하는지를 지시한다.

### 역할

- 지속적으로 앱을 모니터링한다.
- 실행시켜야할 Pod의 수를 유지한다.
- 롤링업데이트를 실행할 수 있다.
- 배포 중에 멈췄다가 다시 배포할 수 있다.
- 배포 후 이전 버전으로 롤백할 수 있다.
- 자동 복구 매커니즘 : 노드가 다운되거나 삭제되면, 컨트롤러가 다른 노드의 인스턴스로 교체한다.

### Deployment Controller

* 생성된 인스턴스를 지속적으로 모니터링한다.
* 노드가 다운되거나 삭제되면, 클러스터 내부의 다른 노드의 인스턴스로 교체시켜준다. (자동 복구 매커니즘)

## StatefulSet

* Deployment와는 다르게 각 파드의 독자성을 유지한다.
* 파드들이 동일한 스펙으로 생성되지만 서로 교체할 수는 없다.

### 사용

StatefulSet은 다음 중 하나 이상이 필요한 애플리케이션에 유용하다.

* 안정된, 고유한 네트워크 식별자
* 안정된, 지속성을 갖는 스토리지
* 순차적인, 정상 배포(graceful deployment)와 스케일링
* 순차적인, 자동 롤링 업데이트

### 제한사항

* 파드에 지정된 스토리지는 관리자에 의해 퍼시스턴트 볼륨 프로비저너를 기반으로 하는 storage class를 요청해서 프로비전하거나 사전에 프로비전이 되어야 한다.
* StatefulSet을 삭제 또는 스케일 다운해도 StatefulSet과 연관된 볼륨이 삭제되지 않는다. 이는 일반적으로 StatefulSet과 연관된 모든 리소스를 자동으로 제거하는 것보다 더 중요한 데이터의 안전을 보장하기 위함이다.
* StatefulSet은 현재 파드의 네트워크 신원을 책임지고 있는 Headless Service가 필요하다. 사용자가 이 서비스를 생성할 책임이 있다.
* StatefulSet의 삭제 시 파드의 종료에 대해 어떠한 보증을 제공하지 않는다. 파드가 순차적이고 정상적으로 종료되도록 하려면, 삭제 전 StatefulSet의 스케일을 0으로 축소할 수 있다.
* 롤링업데이트와 기본 파드 매니지먼트 폴리시(Ordered Ready)를 함께 사용시 복구를 위한 수동 개입이 필요한 파손 상태로 빠질 수 있다.

## Namespace

* 동일한 물리 클러스터를 기반으로 하는 여러 가상 클러스터를 지원한다.
* 리소스의 이름은 Namespace 내에서는 유일해야하지만, Namespace를 통틀어서 유일할 필요는 없다.
* 리소스는 하나의 Namespace에만 있을 수 있다.

#### Namespace와 DNS

* Service를 생성하면 DNS 엔트리가 생성된다.
* 이 엔트리는 \<Service-name>.\<Namespace-name>.svc.cluster.local 의 형식을 갖는다.
* 컨테이너가 \<Service-name>만 사용하는 경우, Namespace 내에 국한된 Service로 연결된다.
* 개발, 스테이징, 운영과 같이 여러 Namespace 내에서 동일한 설정을 사용하는 경우에 유용하다.
* Namespace를 넘어서 접근하기 위해서는, 전체 주소 도메인 이름(FQDN)을 사용해야 한다.

## Service

* 하나의 논리적인 파드 셋과 그 파드들에 접근할 수 있는 정책을 정의하는 추상적 개념이다.
* 트래픽을 라우트한다.
* 종속적인 파드들 사이를 느슨하게 결합되도록 해준다.
* YAML이나 JSON으로 정의한다.
* 대상 파드셋은 보통 LabelSelector에 의해 결정된다.
* 파드가 고유의 IP를 갖고 있지만, 서비스의 도움 없이 클러스터 외부로 노출시킬 수 없다.

### Service Type

#### ClusterIP

* 클러스터 내부 IP로 서비스를 노출시킨다.

* 클러스터 내부에서만 접근할 수 있다.
* 기본 서비스 타입이다.

#### NodePort

* 고정된 포트에 서비스를 노출시킨다.
* NodePort 서비스를 라우트하기 위해서 ClusterIP 서비스를 자동으로 만든다.
* 클러스터 밖에서 `<NodeIP>:<NodePort>`로 접근할 수 있다.
* 컨트롤플레인은 `--service-node-port-range` 플래그에 명시된 범위(기본: 30000~32767) 내에서 포트를 할당한다.
* 특정 IP를 포트에 프록시하기를 원한다면 kube-proxy에서 특정 IP 블록에  `--nodeport-addresses`플래그를 설정할 수 있다. (e.g. 10.0.0.0/8, 192.0.2.0/25)
  * 예를 들어, kube-proxy를 `--nodeport-addresses=127.0.0.1/8` 플래그로 시작하면, kube-proxy는 NodePort 서비스를 위해서 오직 loopback 인터페이스만 선택하게 된다.

#### LoadBalancer

* 클라우드 제공자의 로드밸런서를 사용해 서비스를 외부로 노출시킨다.
* 외부 로드밸런서를 라우트하기 위해 NodePort와 ClusterIP 서비스들을 자동으로 만든다.

#### ExternalName

* 값이 있는 CNAME 레코드를 리턴해서, 서비스와 externalName필드의 내용을 매핑한다. (e.g. foo.bar.example.com)

### Headless Service

* 로드밸런싱 대신, 파드에 연결된 IP를 리턴한다.
* 프록시 대신 파드에 직접 연결하여 통신할 수 있게 한다.
* 클러스터 IP가 할당되지 않는다.
* DNS가 자동으로 구성되는 방법은 서비스에 셀렉터가 정의되어 있는지 여부에 달려있다.

#### 셀렉터가 있는 경우

* 엔드포인트 컨트롤러는 API에서 엔트포인트 레코드를 생성하고
* DNS 구성을 수정하여 서비스를 지원하는 파드를 직접 가리키는 레코드(주소)를 반환한다.

#### 셀렉터가 없는 경우

* 엔드포인트 컨트롤러는 엔드포인트 레코드를 생성하지 않는다.
* 그러나 DNS 시스템은 다음 중 하나를 찾고 구성한다.
  * ExternalName - 유형 서비스에 대한 CNAME 레코드
  * 다른 모든 유형에 대해, 서비스의 이름을 공유하는 모든 엔드포인트에 대한 레코드



## 참고



[^1]: 컨테이너의 라이프사이클을 정의, 배포, 관리하기 위한 API와 인터페이스들을 노출하는 컨테이너 오케스트레이션 레이어